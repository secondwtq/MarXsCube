#include "Common.h"
#include "Pathfinder.h"
#include "Cell.h"

#include "Map.h"

#include <vector>
using namespace std;

namespace Pathfinding {

	namespace {
		int xx = 0, yy = 0;
		// bool InsideOpen[60][60];
		// bool InsideClose[60][60];
		// Abs_Cell *Cells[60][60];
		// CellStruct Fathers[60][60];
		// int G[60][60];
		// int H[60][60];
		// int F[60][60];
		
		bool *InsideOpen;
		bool *InsideClose;
		Abs_Cell **Cells;
		CellStruct *Fathers;
		int *G;
		int *H;
		int *F;

		int ll, ww;

		int numOpen;

		CellStruct minF = CellStruct(0, 0);
	}

	void init(int _x, int _y) {
		xx = _x, yy = _y;
		ll = _x+1, ww = _y+1;
		InsideOpen = new bool[ll*ww];
		InsideClose = new bool[ll*ww];
		Cells = (Abs_Cell**)new int[ll*ww];
		Fathers = new CellStruct[ll*ww];
		G = new int[ll*ww];
		H = new int[ll*ww];
		F = new int[ll*ww];
		for (int i = 0; i < xx; i++)
			for (int j = - yy/2; j < yy/2+1; j++) {
				auto p = CellStruct(i, j);
				Cells[i*xx+j+yy/2] = Map::GetInstance().GetCellAt(p);
			}
	}

	void getMinF() {
		for (int i = 0; i < xx; i++)
			for (int j = 0; j < yy; j++) {
				if ((F[minF.x*xx+minF.y] > F[i*xx+j]) && (InsideOpen[i*xx+j])) { minF.x = i, minF.y = j; }
				else if ((InsideOpen[i*xx+j]) && (!InsideOpen[minF.x*xx+minF.y])) { minF.x = i, minF.y = j; }
			}
	}

	void Find_rec(Abs_Object *obj, CellStruct &pos, CellStruct &dest) {
		// printf("Find_rec %d %d %d\n", pos.x, pos.y, numOpen);
		// Cells[pos.x][pos.y]->ShowCenter = true;
		InsideClose[pos.x*xx + pos.y] = true;
		if (pos == dest) return;

		CellStruct _cells[8];
		for (int i = -1, c = 0; i <= 1; i++)
			for (int j = -1; j <= 1; j++)
				if (i || j) _cells[c++] = CellStruct(pos.x+i, pos.y+j);
		vector<CellStruct> cells;
		for (int i = 0; i < 8; i++) {
			int x = _cells[i].x, y = _cells[i].y;
			if (x >= 0 && x <= xx-1 && y >= 0 && y < yy-1)
				if (Cells[x*xx+y]->PassableTo(obj)) cells.push_back(_cells[i]);
		}

		// printf("find subcells %d\n", cells.size());
		for (size_t i = 0; i < cells.size(); i++) {
			int x = cells[i].x, y = cells[i].y;
			if (!InsideClose[x*xx+y]) {
				bool better = false;
				int _G = G[pos.x*xx+pos.y] + 1;
				H[x*xx+y] = abs(x - dest.x) + abs(y - dest.y);
				F[x*xx+y] = _G + H[x*xx+y];

				if (!InsideOpen[x*xx+y]) {
					numOpen++;
					InsideOpen[x*xx+y] = better = true;
				}
				else if (_G < G[x*xx+y]) better = true;
				else better = false;
				if (better) {
					G[x*xx+y] = _G;
					Fathers[x*xx+y] = pos;
				}
			}
		}
		numOpen--;
		InsideOpen[pos.x*xx+pos.y] = false;
		getMinF();
		Find_rec(obj, minF, dest);
	}

	void Find(Abs_Object *obj, Abs_Cell *src, Abs_Cell *dest) {
		// src->ShowCenter = true;
		// dest->ShowCenter = true;
		// memset(InsideOpen, 0, sizeof(InsideOpen));
		// memset(InsideClose, 0, sizeof(InsideClose));
		// memset(F, 0, sizeof(F));
		// memset(G, 0, sizeof(G));
		// memset(H, 0, sizeof(H));
		if (src->PassableTo(obj) && dest->PassableTo(obj)) {
			memset(InsideOpen, 0, sizeof(bool) * ll * ww);
			memset(InsideClose, 0, sizeof(bool) * ll * ww);
			memset(F, 0, sizeof(int) * ll * ww);
			for (int i = 0; i < xx; i++)
				for (int j = 0; j < yy; j++) {
					Fathers[i*xx+j].x = -1;
					Fathers[i*xx+j].y = -1;
				}
			numOpen = 1;
			CellStruct ss = CellStruct(src->LocCell.x, src->LocCell.y+xx/2);
			CellStruct ds = CellStruct(dest->LocCell.x, dest->LocCell.y+yy/2);
			F[ss.x*xx+ss.y] = abs(ss.x - ds.x) + abs(ss.y - ds.y);
			// printf("calling Find_rec\n");
			Find_rec(obj, ss, ds);

			CellStruct s = Fathers[ds.x*xx+ds.y];
			while (true) {
				Cells[s.x*xx+s.y]->ShowCenter = true;
				CellStruct v = Fathers[s.x*xx+s.y];
				s .x = v.x, s.y = v.y;
				if (s.x == -1) break;
			}
		}
	}
}