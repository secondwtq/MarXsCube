#include "Common.h"
#include "Pathfinder.h"
#include "Cell.h"

#include "Map.h"

#include <vector>
using namespace std;

namespace Pathfinding {

	namespace {
		int xx = 0, yy = 0;
		int xx_, yy_;
		// bool InsideOpen[60][60];
		// bool InsideClose[60][60];
		// Abs_Cell *Cells[60][60];
		// CellStruct Fathers[60][60];
		// int G[60][60];
		// int H[60][60];
		// int F[60][60];
		
		bool *InsideOpen;
		bool *InsideClose;
		Abs_Cell **Cells;
		CellStruct *Fathers;
		int *G;
		int *H;
		int *F;

		int ll, ww;

		int numOpen;

		CellStruct minF = CellStruct(0, 0);
	}

	void init(int _x, int _y) {
		xx = _x, yy = _y, xx_ = _x-1, yy_ = _y-1;
		ll = _x+1, ww = _y+1;
		InsideOpen = new bool[ll*ww];
		InsideClose = new bool[ll*ww];
		Cells = (Abs_Cell**)new int[ll*ww];
		Fathers = new CellStruct[ll*ww];
		G = new int[ll*ww];
		H = new int[ll*ww];
		F = new int[ll*ww];
		memset(InsideOpen, 0, sizeof(bool) * ll * ww);
		for (int i = 0; i < xx; i++)
			for (int j = - yy/2; j < yy/2+1; j++) {
				auto p = CellStruct(i, j);
				Cells[i*xx+j+yy/2] = Map::GetInstance().GetCellAt(p);
			}
	}

	void getMinF() {
		for (int i = 0; i < xx; i++)
			for (int j = 0; j < yy; j++)
				if (((F[minF.x*xx+minF.y] > F[i*xx+j]) && (InsideOpen[i*xx+j])) || ((InsideOpen[i*xx+j]) && (!InsideOpen[minF.x*xx+minF.y])))
					minF.x = i, minF.y = j;
	}

	void Find_rec(Abs_Object *obj, CellStruct &pos, CellStruct &dest) {
		// printf("Find_rec %d %d %d\n", pos.x, pos.y, numOpen);
		InsideClose[pos.x*xx+pos.y] = true;
		if (pos == dest) return;

		CellStruct _cells[8];
		_cells[0].x = pos.x-1, _cells[0].y = pos.y-1;
		_cells[1].x = pos.x-1, _cells[1].y = pos.y;
		_cells[2].x = pos.x-1, _cells[2].y = pos.y+1;

		_cells[3].x = pos.x, _cells[3].y = pos.y-1;
		_cells[4].x = pos.x, _cells[4].y = pos.y+1;

		_cells[5].x = pos.x+1, _cells[5].y = pos.y-1;
		_cells[6].x = pos.x+1, _cells[6].y = pos.y;
		_cells[7].x = pos.x+1, _cells[7].y = pos.y+1;

		CellStruct cells[8];
		unsigned char num = 0;
		for (int i = 0; i < 8; i++) {
			int x = _cells[i].x, y = _cells[i].y;
			if (x >= 0 && x <= xx_ && y >= 0 && y < yy_)
				if (Cells[x*xx+y]->PassableTo(obj)) cells[num++] = _cells[i];
		}

		for (size_t i = 0; i < num; i++) {
			int x = cells[i].x, y = cells[i].y;
			register int offset = x*xx+y;
			if (!InsideClose[offset]) {
				bool better = false;
				int _G = G[pos.x*xx+pos.y] + 1;

				if (!InsideOpen[offset]) /* numOpen++; */ InsideOpen[offset] = better = true;
				else if (_G < G[offset]) better = true;
				else better = false;
				if (better) {
					G[offset] = _G;
					Fathers[offset] = pos;
					int th = abs(x - dest.x) + abs(y - dest.y);
					H[offset] = th;
					F[offset] = _G + th;
				}
			}
		}
		// numOpen--;
		InsideOpen[pos.x*xx+pos.y] = false;
		getMinF();
		Find_rec(obj, minF, dest);
	}

	void Find(Abs_Object *obj, Abs_Cell *src, Abs_Cell *dest) {
		// src->ShowCenter = true;
		// dest->ShowCenter = true;
		// memset(InsideOpen, 0, sizeof(InsideOpen));
		// memset(InsideClose, 0, sizeof(InsideClose));
		// memset(F, 0, sizeof(F));
		// memset(G, 0, sizeof(G));
		// memset(H, 0, sizeof(H));
		if (src->PassableTo(obj) && dest->PassableTo(obj)) {
			memset(InsideOpen, 0, sizeof(bool) * ll * ww);
			memset(InsideClose, 0, sizeof(bool) * ll * ww);

			numOpen = 1;
			CellStruct ss = CellStruct(src->LocCell.x, src->LocCell.y+xx/2);
			CellStruct ds = CellStruct(dest->LocCell.x, dest->LocCell.y+yy/2);
			F[ss.x*xx+ss.y] = abs(ss.x - ds.x) + abs(ss.y - ds.y);
			Fathers[ss.x*xx+ss.y] = CellStruct(-1, -1);
			Find_rec(obj, ss, ds);

			CellStruct v = Fathers[ds.x*xx+ds.y];
			while (ds.x != -1) {
				Cells[ds.x*xx+ds.y]->ShowCenter = true;
				ds.x = v.x, ds.y = v.y;
				v = Fathers[ds.x*xx+ds.y];
			}
		}
	}
}