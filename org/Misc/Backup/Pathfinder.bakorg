#include "Common.h"
#include "Pathfinder.h"
#include "Cell.h"

#include "Map.h"

#include <vector>
using namespace std;

namespace Pathfinding {

	namespace {
		int xx = 0, yy = 0;
		// bool InsideOpen[60][60];
		// bool InsideClose[60][60];
		// Abs_Cell *Cells[60][60];
		// CellStruct Fathers[60][60];
		// int G[60][60];
		// int H[60][60];
		// int F[60][60];
		
		bool *InsideOpen;
		bool *InsideClose;
		Abs_Cell **Cells;
		CellStruct *Fathers;
		int *G;
		int *H;
		int *F;

		int ll, ww;

		int numOpen;

		CellStruct minF = CellStruct(0, 0);
	}

	void init(int _x, int _y) {
		xx = _x, yy = _y;
		ll = _x+2, ww = _y+2;
		InsideOpen = (bool**)new bool[ll*ww];
		InsideClose = (bool**)new bool[ll*ww];
		Cells = (Abs_Cell***)new int[ll*ww];
		Fathers = (CellStruct**)new CellStruct[ll*ww];
		printf("initing\n");
		G = (int**)new int[ll*ww];
		H = (int**)new int[ll*ww];
		F = (int**)new int[ll*ww];
		printf("initing\n");
		for (int i = 0; i < xx+1; i++)
			for (int j = - yy/2+1; j < yy/2+1; j++) {
				auto p = CellStruct(i, j);
				printf("%d %d %X\n", i, j+yy/2, Map::GetInstance().GetCellAt(p));
				Cells[i*xx+j+yy/2] = Map::GetInstance().GetCellAt(p);
			}
	}

	void getMinF() {
		for (int i = 0; i < xx; i++)
			for (int j = 0; j < yy; j++) {
				if ((F[minF.x][minF.y] > F[i][j]) && (InsideOpen[i][j])) { minF.x = i, minF.y = j; }
				else if ((InsideOpen[i][j]) && (!InsideOpen[minF.x][minF.y])) { minF.x = i, minF.y = j; }
			}
	}

	void Find_rec(Abs_Object *obj, CellStruct &pos, CellStruct &dest) {
		// printf("Find_rec %d %d %d\n", pos.x, pos.y, numOpen);
		// Cells[pos.x][pos.y]->ShowCenter = true;
		InsideClose[pos.x][pos.y] = true;
		if (pos == dest) return;

		CellStruct _cells[8];
		for (int i = -1, c = 0; i <= 1; i++)
			for (int j = -1; j <= 1; j++)
				if (i || j) _cells[c++] = CellStruct(pos.x+i, pos.y+j);
		vector<CellStruct> cells;
		for (int i = 0; i < 8; i++) {
			int x = _cells[i].x, y = _cells[i].y;
			if (x >= 0 && x <= xx-1 && y >= 0 && y < yy-1)
				if (Cells[x][y]->PassableTo(obj)) cells.push_back(_cells[i]);
		}

		// printf("find subcells %d\n", cells.size());
		for (size_t i = 0; i < cells.size(); i++) {
			int x = cells[i].x, y = cells[i].y;
			if (!InsideClose[x][y]) {
				bool better = false;
				int _G = G[pos.x][pos.y] + 1;
				H[x][y] = abs(x - dest.x) + abs(y - dest.y);
				F[x][y] = _G + H[x][y];

				if (!InsideOpen[x][y]) {
					numOpen++;
					InsideOpen[x][y] = better = true;
				}
				else if (_G < G[x][y]) better = true;
				else better = false;
				if (better) {
					G[x][y] = _G;
					Fathers[x][y] = pos;
				}
			}
		}
		numOpen--;
		InsideOpen[pos.x][pos.y] = false;
		getMinF();
		Find_rec(obj, minF, dest);
	}

	void Find(Abs_Object *obj, Abs_Cell *src, Abs_Cell *dest) {
		printf("finding\n");
		// src->ShowCenter = true;
		// dest->ShowCenter = true;
		// memset(InsideOpen, 0, sizeof(InsideOpen));
		// memset(InsideClose, 0, sizeof(InsideClose));
		// memset(F, 0, sizeof(F));
		// memset(G, 0, sizeof(G));
		// memset(H, 0, sizeof(H));
		memset(InsideOpen, 0, sizeof(bool) * ll * ww);
		memset(InsideClose, 0, sizeof(bool) * ll * ww);
		memset(F, 0, sizeof(int) * ll * ww);
		memset(G, 0, sizeof(int) * ll * ww);
		memset(H, 0, sizeof(int) * ll * ww);
		for (int i = 0; i < xx; i++)
			for (int j = 0; j < yy; j++) {
				Fathers[i][j].x = -1;
				Fathers[i][j].y = -1;
			}
		numOpen = 1;
		CellStruct ss = CellStruct(src->LocCell.x, src->LocCell.y+xx/2);
		CellStruct ds = CellStruct(dest->LocCell.x, dest->LocCell.y+yy/2);
		F[ss.x][ss.y] = abs(ss.x - ds.x) + abs(ss.y - ds.y);
		printf("calling Find_rec\n");
		Find_rec(obj, ss, ds);

		CellStruct s = Fathers[ds.x][ds.y];
		while (true) {
			Cells[s.x][s.y]->ShowCenter = true;
			CellStruct v = Fathers[s.x][s.y];
			s .x = v.x, s.y = v.y;
			if (s.x == -1) break;
		}
	}
}